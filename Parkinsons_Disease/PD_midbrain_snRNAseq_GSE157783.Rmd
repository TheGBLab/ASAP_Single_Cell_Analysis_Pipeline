---
title: "PD_midbrain_snRNAseq_GSE157783"
author: "Lee Marshall"
date: "2020_01_19 - `r format(Sys.time(), '%Y_%m_%d')`"
output: 
  html_document:
    code_folding: show
    self_contained: yes
    toc_float: TRUE
    theme: yeti
---

PD_midbrain_snRNAseq_GSE157783

# PD_midbrain_snRNAseq_GSE157783 {.tabset .tabset-fade .tabset-pills}

PAPER  
"Single-cell sequencing of the human midbrain reveals glial activation and a neuronal state specific to Parkinson’s disease"  
5 iPD and 6 Healthy control midbrain snRNAseq 


## Resources

```{bash Resources, eval=FALSE}
#---------- Seurat  
https://satijalab.org/seurat/vignettes.html  
https://ucdavis-bioinformatics-training.github.io/2017_2018-single-cell-RNA-sequencing-Workshop-UCD_UCB_UCSF/day2/scRNA_Workshop-PART1.html  
https://hbctraining.github.io/scRNA-seq/lessons/04_SC_quality_control.html
https://scrnaseq-course.cog.sanger.ac.uk/website/biological-analysis.html#pseudotime-analysis
https://liulab-dfci.github.io/bioinfo-combio/scrna1.html#intro-to-scrna-seq
http://bioconductor.org/books/release/OSCA/integrating-datasets.html#performing-mnn-correction

#---------- Scanpy – Single-Cell Analysis in Python
https://scanpy.readthedocs.io/en/stable/

#---------- Brain single nuclei Papers  
"A single-cell atlas of the human substantia nigra reveals cell-specific pathways associated with neurological disorders" contains celltype markers

SYNAPSE - create project to download sequencing data
https://www.synapse.org/#!Synapse:syn5550382
https://www.nature.com/articles/s41586-019-1195-2
"Single-cell transcriptomic analysis of Alzheimer’s disease" contains celltype markers

https://portal.brain-map.org/atlases-and-data/rnaseq
https://portal.brain-map.org/atlases-and-data/rnaseq/human-m1-10x
https://www.biorxiv.org/content/10.1101/2020.03.31.016972v2
"Evolution of cellular diversity in primary motor cortex of human, marmoset monkey, and mouse"

"Integrative single-cell analysis of transcriptional and epigenetic states in the human adult brain"contains celltype markers

#---------- Multiplexing
https://www.nature.com/articles/s41467-019-10756-2
"Nuclei multiplexing with barcoded antibodies for single-nucleus genomics"

ASAP-SEQ
https://cite-seq.com/asapseq/
https://www.biorxiv.org/content/10.1101/2020.09.08.286914v1

#---------- Multiomic single cell papers
https://www.nature.com/articles/s41467-018-03149-4
"scNMT-seq enables joint profiling of chromatin accessibility DNA methylation and transcription in single cells"

#---------- Sample Deconvolution 
DemuxEM - a computational tool that detects inter-sample multiplets and assigns singlets to their sample of origin
https://kco-cloud.readthedocs.io/en/latest/hashing_cite_seq.html

cellsnp-lite - assigns cells to donors and detects doublets, even without genotyping reference
https://github.com/single-cell-genetics/cellsnp-lite

scSplit - Genotype-free demultiplexing of pooled single-cell RNA-seq, using a hidden state model for identifying genetically distinct samples within a mixed population
https://github.com/jon-xu/scSplit

demuxlet - Genetic multiplexing of barcoded single cell RNA-seq
https://github.com/statgen/demuxlet

#---------- Doublets
DoubletFinder - an R package that predicts doublets in single-cell RNA sequencing data
#object_filtered <- subset(x = object, idents = "doublet", invert = TRUE)
#object_filtered <- subset(x = object, subset = "CD3E" > EXP_VALUE, invert = TRUE)

```

## Packages & Session
  
```{r knitr}
setwd("/Volumes/projects_secondary/bras/Lee/ASAP/PD_midbrain_snRNAseq_GSE157783")
knitr::opts_chunk$set(warning=FALSE, message=FALSE, cache=FALSE, error=FALSE, cache.lazy=FALSE)
#knitr::opts_knit$set(root.dir = '/Volumes/projects_secondary/bras/Lee/PPMI/DLB')
#options(scipen=999)
#options(stringsAsFactors = FALSE)

# Chunk Options  
# include = FALSE, runs code, prevents code and results from appearing  
# echo = FALSE, runs code, prevents code from appearing but not the results  
# eval = FALSE, does not run code  
# message = FALSE prevents messages that are generated by code from appearing 
# warning = FALSE prevents warnings that are generated by code from appearing 
# fig.cap = "..." adds a caption to graphical results.
```

```{r library}
#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("fgsea")
#install.packages('metap')
library(betareg)
library(corrplot)
library(cowplot)
library(data.table)
library(DoubletFinder)
library(dplyr)
library(fgsea)
library(ggplot2)
library(ggpubr)
library(gprofiler2)
library(knitr)
library(kableExtra)
library(lubridate)
library(magrittr)
library(metap)
library(multtest)
library(parallel)
library(purrr)
library(RColorBrewer)
library(readr)
library(reshape2)
library(reticulate)
library(rmarkdown)
library(Seurat)
library(stringr)
library(tibble)
library(tidyr)
library(tidyverse)
library(viridis)
```

```{r session}
sessionInfo()
```

## Cellranger
  
cellranger-4.0.0  
genome annotation indexed with gtf containing unspliced genes  
  
```{bash SRA, eval=FALSE}
#--------- Download SRA data from NCBI

https://www.ncbi.nlm.nih.gov/Traces/study/?acc=PRJNA662780&o=acc_s%3Aa

module load sratoolkit/2.10.8
qsubs -d -a srr_names -n sratoolkit_prefetch -s "prefetch -X 20G SAMPLE"
qsubs -d -a srr_names -n sartoolkit_fastqdump -s "fastq-dump --split-files /home/lee.marshall/bras_primary/software/sratoolkit/ncbi/sra/sra/SAMPLE.sra --outdir fastq"

#--------- Rename fastq samples

while read line ; do mv $(awk '{print $1"_1.fastq",$2"_I1_001.fastq"}' <<<$line) ; done < ../srr_samples
while read line ; do mv $(awk '{print $1"_2.fastq",$2"_R1_001.fastq"}' <<<$line) ; done < ../srr_samples
while read line ; do mv $(awk '{print $1"_3.fastq",$2"_R2_001.fastq"}' <<<$line) ; done < ../srr_samples

#--------- gzip all fastq files

qsubs -a sample_names -n gzip_fastq -s "gzip fastq/SAMPLE"
```

```{bash Cellranger, eval=FALSE}

#---------- premRNA GTF
 
awk 'BEGIN{FS="\t"; OFS="\t"} $3 == "transcript"{ print; $3="exon"; $9 = gensub("(transcript_id\\s\"{0,1})([^;\"]+)(\"{0,1});", "\\1\\2_premrna\\3;", "g", $9); print; next}{print}' \
refdata-gex-GRCh38-2020-A/genes/genes.gtf > refdata-gex-GRCh38-2020-A.premrna.gtf
 
 
#---------- premRNA Cellranger Reference
 
module load cellranger/cellranger-4.0.0
qsubs -n cellranger_mkref -s "cellranger mkref --genome=refdata-gex-GRCh38-2020-A_premrna --fasta=refdata-gex-GRCh38-2020-A/fasta/genome.fa --genes=refdata-gex-GRCh38-2020-A.premrna.gtf"
 
 
#---------- premRNA Cellranger Count
 
module load cellranger/cellranger-4.0.0
qsubs -n cellranger_count -c 5 -w 48 -a sample_names -s "cellranger count --sample=SAMPLE --id=SAMPLE_count --fastqs=./fastq --chemistry=SC3Pv3 --transcriptome=/home/lee.marshall/bras_primary/software/cellranger/refdata-gex-GRCh38-2020-A_premrna"

```

## Seurat QC 
  
Quality control graphs used to identify filtering thresholds  
  
```{r Seurat_QC, eval=FALSE}
#---------- Seurat_Object
# Get files
dir <- "counts/"
samples <- paste0(c("IPD1", "IPD2", "IPD3", "IPD4", "IPD5", 
                    "C1", "C2", "C3", "C4", "C5", "C6"), "_count")
# Count Matrix
seurat_counts <- lapply(samples, function(i){
  count <- Read10X(data.dir=paste0(dir,i,"/outs/filtered_feature_bc_matrix/"),
                  gene.column=2, # col1 Ensemble, col2 Symbol
                  unique.features=TRUE,
                  strip.suffix=TRUE) 
  seurat_obj <- CreateSeuratObject(counts=count, 
                                   project=i,
                                   min.cells=10,
                                   min.genes=200)
})
# Merge Seurat Objects
seurat_combined <- merge(x = seurat_counts[[1]], 
                               y = seurat_counts[2:length(seurat_counts)],
                               add.cell.ids = unlist(samples), 
                               project="Aging_Mice_GSE129788")
# Alternative Seurat Object
#d10x.data <- sapply(samples, function(i){
#  d10x <- Read10X(file.path(dir,i,"/outs/filtered_feature_bc_matrix/"))
#  colnames(d10x) <- paste(sapply(strsplit(colnames(d10x),split="-"),'[[',1L),i,sep="-")
#  d10x
#})
#d10x.cbind <- do.call("cbind", d10x.data)
#d10x.combined <- CreateSeuratObject(
#  counts=d10x.cbind,
#  project="DLB_snRNAseq", 
#  min.cells = 10,
#  min.genes = 200,
#  names.field = 2,
#  names.delim = "\\-")

#---------- Add Metadata
#View(seurat_combined@meta.data)
# orig.ident: contains the sample identity if known
# nCount_RNA: number of UMIs per cell
# nFeature_RNA: number of genes detected per cell
# Add number of genes per UMI for each cell to metadata
seurat_combined$log10GenesPerUMI <- log10(seurat_combined$nFeature_RNA) / log10(seurat_combined$nCount_RNA)
# Compute percent mito ratio
seurat_combined$mitoRatio <- PercentageFeatureSet(object = seurat_combined, pattern = "^MT-")
seurat_combined$mitoRatio <- seurat_combined@meta.data$mitoRatio / 100
# Create metadata dataframe
metadata <- seurat_combined@meta.data
# Add cell IDs to metadata
metadata$cells <- rownames(metadata)
# Rename columns
metadata <- metadata %>%
        dplyr::rename(seq_folder = orig.ident,
                      nUMI = nCount_RNA,
                      nGene = nFeature_RNA)
# Create sample column
metadata$sample <- NA
metadata$sample[which(str_detect(metadata$cells,"^IPD1"))] <- "IPD1"
metadata$sample[which(str_detect(metadata$cells,"^IPD2"))] <- "IPD2"
metadata$sample[which(str_detect(metadata$cells,"^IPD3"))] <- "IPD3"
metadata$sample[which(str_detect(metadata$cells,"^IPD4"))] <- "IPD4"
metadata$sample[which(str_detect(metadata$cells,"^IPD5"))] <- "IPD5"
metadata$sample[which(str_detect(metadata$cells,"^C1"))] <- "HC1"
metadata$sample[which(str_detect(metadata$cells,"^C2"))] <- "HC2"
metadata$sample[which(str_detect(metadata$cells,"^C3"))] <- "HC3"
metadata$sample[which(str_detect(metadata$cells,"^C4"))] <- "HC4"
metadata$sample[which(str_detect(metadata$cells,"^C5"))] <- "HC5"
metadata$sample[which(str_detect(metadata$cells,"^C6"))] <- "HC6"

# Create group column
metadata$group <- NA
metadata$group[which(str_detect(metadata$cells,"^IPD1"))] <- "IPD"
metadata$group[which(str_detect(metadata$cells,"^IPD2"))] <- "IPD"
metadata$group[which(str_detect(metadata$cells,"^IPD3"))] <- "IPD"
metadata$group[which(str_detect(metadata$cells,"^IPD4"))] <- "IPD"
metadata$group[which(str_detect(metadata$cells,"^IPD5"))] <- "IPD"
metadata$group[which(str_detect(metadata$cells,"^C1"))] <- "HC"
metadata$group[which(str_detect(metadata$cells,"^C2"))] <- "HC"
metadata$group[which(str_detect(metadata$cells,"^C3"))] <- "HC"
metadata$group[which(str_detect(metadata$cells,"^C4"))] <- "HC"
metadata$group[which(str_detect(metadata$cells,"^C5"))] <- "HC"
metadata$group[which(str_detect(metadata$cells,"^C6"))] <- "HC"

# Add metadata back to Seurat object
seurat_combined@meta.data <- metadata

# rm data
rm(seurat_counts, metadata)

# Create .RData object to load at any time
save(seurat_combined, file="seurat_combined.RData")
```

```{r Seurat_QC_Cell_Counts}
#---------- Cell_Counts
# Load data
load("seurat_combined.RData")

# Visualize the number of cell counts per sample
seurat_combined@meta.data %>% 
  	ggplot(aes(x=sample, fill=sample)) + 
  	geom_bar() + 
  	ggtitle("Number of Cells") + 
    theme_classic() + 
  	theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) + 
  	theme(plot.title = element_text(hjust=0.5, face="bold"))
```

```{r Seurat_QC_UMI_Counts_per_cell}
#---------- UMI_Counts_per_cell (transcripts)
# Visualize the number UMIs/transcripts per cell
seurat_combined@meta.data %>% 
  	ggplot(aes(color=sample, x=nUMI, fill= sample)) + 
  	geom_density(alpha = 0.2) + 
  	geom_vline(xintercept = 1000, linetype="dashed", colour = "red3") + 
  	geom_vline(xintercept = 20000, linetype="dashed", colour = "red3") + 
    ggtitle("Number of UMIs/Transcripts per Cell") + 
  	ylab("Cell density") + 
    scale_x_log10() + 
  	theme_classic() + 
  	theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) + 
  	theme(plot.title = element_text(hjust=0.5, face="bold"))
```

```{r Seurat_QC_Genes_per_cell}
#---------- Genes_per_cell
# Visualize the distribution of genes detected per cell via histogram
p1 <- seurat_combined@meta.data %>% 
  	ggplot(aes(color=sample, x=nGene, fill= sample)) + 
  	geom_density(alpha = 0.2) + 
  	geom_vline(xintercept = 500, linetype="dashed", colour = "red3") + 
  	geom_vline(xintercept = 10000, linetype="dashed", colour = "red3") + 
    ggtitle("Number of Genes per Cell") + 
  	scale_x_log10() + 
    theme_classic() +
  	theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) + 
  	theme(plot.title = element_text(hjust=0.5, face="bold"))

# Visualize the distribution of genes detected per cell via boxplot
p2 <- seurat_combined@meta.data %>% 
  	ggplot(aes(x=sample, y=log10(nGene), fill=sample)) + 
  	geom_boxplot() + 
    ggtitle("Number of Genes vs Number of Cells") +   
  	theme_classic() +
  	theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  	theme(plot.title = element_text(hjust=0.5, face="bold"))

# Plots
cowplot::plot_grid(p1, p2, ncol=2)
```

```{r Seurat_QC_UMI_Counts_vs_Genes}
#---------- UMI_Counts_vs_Genes
# Visualize the correlation between genes detected and number of UMIs/transcripts and determine whether strong presence of cells with low numbers of genes/UMIs
seurat_combined@meta.data %>% 
  	ggplot(aes(x=nUMI, y=nGene, color=mitoRatio)) + 
  	geom_point() + 
  	geom_vline(xintercept = 1000, linetype="dashed", colour = "red3") + 
  	geom_vline(xintercept = 20000, linetype="dashed", colour = "red3") + 
    geom_hline(yintercept = 500, linetype="dashed", colour = "red3") + 
    geom_hline(yintercept = 10000, linetype="dashed", colour = "red3") + 
    ggtitle("Number of UMIs/Transcripts vs Number of Cells") +   
  	stat_smooth(method=lm) + 
  	scale_x_log10() + 
  	scale_y_log10() + 
  	theme_classic() + 
    scale_colour_viridis_c() +
  	facet_wrap(~sample)
```

```{r Seurat_QC_Mitochondrial_counts_ratio}
#---------- Mitochondrial_counts_ratio
# Visualize the distribution of mitochondrial gene expression detected per cell
seurat_combined@meta.data %>% 
  	ggplot(aes(color=sample, x=mitoRatio, fill=sample)) + 
  	geom_density(alpha = 0.2) + 
  	geom_vline(xintercept = 0.20, linetype="dashed", colour = "red3") + 
    ggtitle("Mitochondrial Counts Ratio") + 
  	ylab("Cell density") + 
    scale_x_log10() + 
  	theme_classic()
```

```{r Seurat_QC_Complexity}
#---------- Complexity
# Visualize the overall complexity of the gene expression by visualizing the genes detected per UMI
seurat_combined@meta.data %>%
  	ggplot(aes(x=log10GenesPerUMI, color = sample, fill=sample)) + 
  	geom_density(alpha = 0.2) +
  	geom_vline(xintercept = 0.85, linetype="dashed", colour = "red3") + 
    ggtitle("Complexity Genes per UMI") + 
  	ylab("Cell density") + 
  	theme_classic()
```

## Seurat Filtering 
  
Remove poor quilty cells and doublets  
Keep  high quality cells without removing biologically relevant cells  
* nUMI >= 1000  
* nUMI <= 20000  
* nGene >= 500  
* nGene <= 10000  
* mitoRatio < 0.20  
* log10GenesPerUMI > 0.85  
  
```{r Seurat_Filtering, eval=FALSE}
#---------- Seurat_Filtering
# Filter out low quality reads using selected thresholds - these will change with experiment
seurat_filtered <- subset(x = seurat_combined, 
                         subset= (nUMI >= 1000) & 
                           (nUMI <= 20000) & 
                           (nGene >= 500) & 
                           (nGene <= 10000) &
                           (mitoRatio < 0.20) & 
                           (log10GenesPerUMI > 0.85))

# Create .RData object to load at any time
save(seurat_filtered, file="seurat_filtered.RData")
```

```{r Seurat_Filtering_Cell_Counts}
#---------- Cell_Counts_Pre_and_Post_Filtered 
# Load data
load("seurat_filtered.RData")

# Number of Cells
nCells_pre <- seurat_combined@meta.data$sample %>% 
                      table() %>% 
                      as.data.frame() %>% 
                      dplyr::rename(Sample=".")

nCells_post <- seurat_filtered@meta.data$sample %>% 
                      table() %>% 
                      as.data.frame() %>% 
                      dplyr::rename(Sample=".")

cbind(nCells_pre, nCells_post) %>% kable(caption="Number of Cells", format.args = list(big.mark = ",")) %>% kable_styling(c("striped", "bordered")) %>% add_header_above(c("Pre-Filtered" = 2, "Post-Filtered" = 2))
```

```{r Seurat_Filtering_Violin_plots}
# Violin_plots
p1 <- VlnPlot(object = seurat_combined, features = c("nGene", "nUMI", "mitoRatio", "log10GenesPerUMI"), ncol = 4, pt.size=0, group.by="sample") 

p2 <- VlnPlot(object = seurat_filtered, features = c("nGene", "nUMI", "mitoRatio", "log10GenesPerUMI"), ncol = 4, pt.size=0, group.by="sample") 

cowplot::plot_grid(p1, p2, labels=c("Pre-Filtered", "Post-Filtered"), nrow=2)
```

```{r Seurat_Filtering_Scatter_plots}
# Scatter_plots
p1 <- FeatureScatter(object = seurat_combined, feature1 = "nGene", feature2 = "nUMI", pt.size=0.01, group.by="sample")
p2 <- FeatureScatter(object = seurat_combined, feature1 = "nGene", feature2 = "mitoRatio", pt.size=0.01, group.by="sample")
p3 <- FeatureScatter(object = seurat_filtered, feature1 = "nGene", feature2 = "nUMI", pt.size=0.01, group.by="sample")
p4 <- FeatureScatter(object = seurat_filtered, feature1 = "nGene", feature2 = "mitoRatio", pt.size=0.01, group.by="sample")

# Plots
cowplot::plot_grid(p1, p3, p2, p4, labels=c("Pre-Filtered", "Post-Filtered"), nrow=2, ncol=2)

# Remove data
rm(seurat_combined)
```


## Seurat Cell Cycle Scoring 
  
Determine if cell cycle regression is required  
  
```{r Cell_Cycle_Scoring, eval=FALSE}
#---------- Cell_Cycle_Scoring
# Normalize the counts
seurat_phase <- NormalizeData(seurat_filtered)

# Load cell cycle markers
load(file="seurat_cycle.rda")

# Score cells for cell cycle
seurat_phase <- CellCycleScoring(seurat_phase, 
                                 g2m.features = g2m_genes, 
                                 s.features = s_genes)

# Identify the most variable genes
seurat_phase <- FindVariableFeatures(seurat_phase, 
                     selection.method = "vst",
                     nfeatures = 2000, 
                     verbose = FALSE)

# Scale the counts
seurat_phase <- ScaleData(seurat_phase)

# Perform PCA
seurat_phase <- RunPCA(seurat_phase)

# Create .RData object to load at any time
save(seurat_phase, file="seurat_phase.RData")
```

```{r Cell_Cycle_Scoring_PCA}
# Load data
load("seurat_phase.RData")

# Plot the PCA colored by cell cycle phase
DimPlot(seurat_phase,
        reduction = "pca",
        group.by= "Phase",
        split.by = "Phase")
# you can regress out the s and g2m score
# alternatively you could only regress out the s-g2m score to keep non-cuyling and cycling cell differences
DimPlot(seurat_phase,
        reduction = "pca",
        group.by= "Phase",
        split.by = "sample")
# Remove data
rm(seurat_phase)
```


## Seurat Batch Correction
  
Standard batch correction is not considered standard anymore  
SCTransform batch correction allows for better normalization  
SCTransform method models the UMI counts using a regularized negative binomial  
model to remove the variation due to sequencing depth (total nUMIs per cell),  
while adjusting the variance based on pooling information across genes with   
similar abundances (similar to some bulk RNA-seq methods).  
  
```{r Batch_Correction_SCTransform, eval=FALSE}
#---------- Batch_Correction_SCTransform
# The data is preprocessed by splitting into individual ‘assays’. 
# In this experiment, each individual sample is considered an ‘assay’.
# Ensure the dataset used here is the non-normalized dataset
DefaultAssay(seurat_filtered) <- "RNA"
# Split seurat object by condition to perform cell cycle scoring and SCT on all samples
seurat_split <- SplitObject(seurat_filtered, split.by = "sample")
load(file="seurat_cycle.rda")
for (i in 1:length(seurat_split)) {
    seurat_split[[i]] <- NormalizeData(seurat_split[[i]], 
                                       verbose = TRUE)
    seurat_split[[i]] <- CellCycleScoring(seurat_split[[i]], 
                                          g2m.features=g2m_genes, 
                                          s.features=s_genes)
    seurat_split[[i]] <- SCTransform(seurat_split[[i]], 
                                     vars.to.regress = c("mitoRatio"))
}

# Select the most variable features to use for integration
seurat_features <- SelectIntegrationFeatures(object.list = seurat_split, 
                                            nfeatures = 3000) 
# Prepare the SCT list object for integration
seurat_split <- PrepSCTIntegration(object.list = seurat_split, 
                                   anchor.features = seurat_features)
# Find best buddies - can take a while to run
seurat_anchors <- FindIntegrationAnchors(object.list = seurat_split, 
                                        normalization.method = "SCT", 
                                        anchor.features = seurat_features)
# Integrate across conditions
seurat_integrated <- IntegrateData(anchorset = seurat_anchors, 
                                   normalization.method = "SCT")
# Run PCA
seurat_integrated <- RunPCA(object = seurat_integrated)
ElbowPlot(object = seurat_integrated, 
          ndims = 50)
# Run UMAP
seurat_integrated <- RunUMAP(seurat_integrated, 
                             dims = 1:40,
			                       reduction = "pca")
# Create .RData object to load at any time
save(seurat_integrated, file="seurat_integrated.RData")
# Remove data
rm(seurat_filtered, seurat_anchors, seurat_split)
```

```{r Batch_Correction_SCTransform_PCA, warning=FALSE}
# Load data
load(file="seurat_integrated.RData")


# Plot PCA
PCAPlot(seurat_integrated,
        group.by = "sample",
        split.by = "group") 

PCAPlot(seurat_integrated,
        group.by = "sample") 

# Explore heatmap of PCs
DimHeatmap(seurat_integrated, 
           dims = 1:9, 
           cells = 500, 
           balanced = TRUE)

# Printing out the most variable genes driving PCs
print(x = seurat_integrated[["pca"]], 
      dims = 1:9, 
      nfeatures = 5)

# Plot the elbow plot
ElbowPlot(object = seurat_integrated, 
          ndims = 50)
```

```{r Batch_Correction_SCTransform_UMAP}
# Plot UMAP                             
DimPlot(seurat_integrated, reduction = "umap", group.by = "sample")
```


## Seurat Clustering_Cells

Seurat uses a graph-based clustering approach, which embeds cells in a graph  
structure, using a K-nearest neighbor (KNN) graph (by default), with edges  
drawn between cells with similar gene expression patterns.  

The resolution is an important argument that sets the “granularity” of the  
downstream clustering and will need to be optimized for every individual  
experiment. For datasets of 3,000 - 5,000 cells, the resolution set between   
0.4-1.4 generally yields good clustering. Increased resolution values lead to a  
greater number of clusters, which is often required for larger datasets.  

```{r Clustering_Cells, eval=FALSE}
#---------- Clustering_Cells
# Determine the K-nearest neighbor graph
seurat_cluster <- FindNeighbors(object = seurat_integrated, 
                                dims = 1:40)

# Determine the clusters for various resolutions                                
seurat_cluster <- FindClusters(object = seurat_cluster,
                               resolution = c(0.2, 0.4, 0.6, 0.8, 1.0, 1.2))
# Explore resolutions
# seurat_cluster@meta.data %>% View()

# Remove data
rm(seurat_integrated)

# Create .RData object to load at any time
save(seurat_cluster, file="seurat_cluster.RData")
```

```{r Clustering_Cells_UMAP_1, fig.cap="UMAP_0.4", out.width='100%'}
# Load data
load("seurat_cluster.RData")

#---------- Explore resolutions
# Assign identity of clusters
Idents(object = seurat_cluster) <- "integrated_snn_res.1.2"

# Plot UMAP                             
DimPlot(seurat_cluster, reduction = "umap", label = TRUE)
```


## Seurat UMAP_Summary
  
UMAP resolution used 1.2  

Determine whether clusters represent true cell types or cluster due to   
biological or technical variation, such as clusters of cells in the S phase of   
the cell cycle, clusters of specific batches, or cells with high mitochondrial  
content. 

```{r UMAP_Summary_nCells}
# Extract identity and sample information from seurat object to determine the number of cells per cluster per sample
nCells <- FetchData(seurat_cluster, 
                     vars = c("ident", "sample")) %>%
           dplyr::count(ident, sample) %>%
           tidyr::spread(ident, n)

# View table
#View(n_cells)
kable(nCells, caption="Number of Cells", format.args = list(big.mark = ",")) %>% kable_styling(c("striped", "bordered"))

# UMAP of cells in each cluster by sample
DimPlot(seurat_cluster, 
        label = TRUE, 
        split.by = "sample")  + NoLegend()

# plot
FeaturePlot(seurat_cluster, 
            reduction = "umap", 
            features = c("nUMI", "nGene", "log10GenesPerUMI", "mitoRatio"),
            pt.size = 0.4, 
            sort.cell = TRUE,
            min.cutoff = 'q10',
            label = TRUE)
```

```{r UMAP_Summary_nCells_phase}
# cell phases
nCells_phase <-FetchData(seurat_cluster, 
                          vars = c("ident", "Phase")) %>%
                dplyr::count(ident, Phase) %>%
                tidyr::spread(ident, n)
# View table
#View(n_cells)

kable(nCells, caption="Number of Cells", format.args = list(big.mark = ",")) %>% kable_styling(c("striped", "bordered"))
# Explore whether clusters segregate by cell cycle phase
DimPlot(seurat_cluster,
        label = TRUE, 
        split.by = "Phase")  + NoLegend()

# plot
FeaturePlot(seurat_cluster, 
            reduction = "umap", 
            features = c("S.Score", "G2M.Score"),
            pt.size = 0.4, 
            sort.cell = TRUE,
            min.cutoff = 'q10',
            label = TRUE)
```

```{r UMAP_Summary_PCs}
# Defining the information in the seurat object of interest
# Extracting this data from the seurat object
umap_data <- FetchData(seurat_cluster, 
                     vars = c(paste0("PC_", 1:16), 
                              "ident", "UMAP_1", "UMAP_2"))

# Extract the UMAP coordinates for the first 10 cells
#seurat_cluster@reductions$umap@cell.embeddings[1:10, 1:2]
# Adding cluster label to center of cluster on UMAP
umap_label <- FetchData(seurat_cluster, 
                        vars = c("ident", "UMAP_1", "UMAP_2"))  %>%
               group_by(ident) %>%
               summarise(x=mean(UMAP_1), y=mean(UMAP_2))

# Plotting a UMAP plot for each of the PCs
map(paste0("PC_", 1:16), function(pc){
        ggplot(umap_data, 
               aes(UMAP_1, UMAP_2)) +
                geom_point(aes_string(color=pc), 
                           alpha = 0.7) +
                scale_color_gradient(guide = FALSE, 
                                     low = "grey90", 
                                     high = "blue")  +
                geom_text(data=umap_label, 
                          aes(label=ident, x, y)) +
                ggtitle(pc)
}) %>% 
        plot_grid(plotlist = .)

# Explore heatmap of PCs
DimHeatmap(seurat_cluster, 
           dims = 1:9, 
           cells = 500, 
           balanced = TRUE)

# Printing out the most variable genes driving PCs
print(x = seurat_cluster[["pca"]], 
      dims = 1:9, 
      nfeatures = 5)
```


## Seurat Marker_Identification
  
Generate cell type-specific clusters and use known markers to determine the  
identities of the clusters.  

Seurat’s FeaturePlot() function let’s us easily explore the known markers on top of our UMAP visualizations. Let’s go through and determine the identities of the clusters. To access the expression levels of all genes, rather than just the 3000 most highly variable genes, we can use the normalized count data stored in the RNA assay slot.  

```{r Marker_Identification, eval=FALSE}
#---------- Marker_Identification
# Select the RNA counts slot to be the default assay
DefaultAssay(seurat_cluster) <- "RNA"

# Normalize RNA data for visualization purposes
seurat_markers <- NormalizeData(seurat_cluster, verbose = FALSE)

# Create .RData object to load at any time
save(seurat_markers, file="seurat_markers.RData")
```

```{r Marker_Identification_Paper}
#---------- Marker_Identification
## remove the x-axis text and tick
## plot.margin to adjust the white space between each plot.
## ... pass any arguments to VlnPlot in Seurat
vlnplot_gg <- function(obj, 
                          feature, 
                          pt.size = 0, 
                          plot.margin = unit(c(-0.75, 0, -0.75, 0), "cm"),
                          ...){
  p <- VlnPlot(obj, features = feature, pt.size = pt.size, ... ) + 
    xlab("") + 
    ylab(feature) + 
    ggtitle("") + 
    theme(legend.position = "none", 
          axis.text.x = element_blank(), 
          axis.ticks.x = element_blank(), 
          axis.title.y = element_text(size = rel(1), angle = 0), 
          axis.text.y = element_text(size = rel(1)), 
          plot.margin = plot.margin ) 
  return(p)
}

## extract the max value of the y axis
vlnplot_max<- function(p){
  ymax<- max(ggplot_build(p)$layout$panel_scales_y[[1]]$range$range)
  return(ceiling(ymax))
}

## main function
vlnplot_stacked <- function(obj, features,
                          pt.size = 0, 
                          plot.margin = unit(c(-0.75, 0, -0.75, 0), "cm"),
                          ...){
  plot_list<- purrr::map(features, function(x) vlnplot_gg(obj = obj,
                                                          feature = x, ...))
  # Add back x-axis title to bottom plot. patchwork is going to support this?
  plot_list[[length(plot_list)]] <- plot_list[[length(plot_list)]] + 
                                      theme(axis.text.x=element_text(), 
                                            axis.ticks.x = element_line())
  # change the y-axis tick to only max value 
  ymaxs <- purrr::map_dbl(plot_list, vlnplot_max)
  plot_list <- purrr::map2(plot_list, ymaxs, function(x,y) x + 
                             scale_y_continuous(breaks = c(y)) + 
                             expand_limits(y = y))
  p <- patchwork::wrap_plots(plotlist = plot_list, ncol = 1)
  return(p)
}
```

```{r Marker_Identification_celltypes}
# Load data
load("seurat_markers.RData")

#---------- UMAP
DimPlot(seurat_markers, reduction="umap", label = TRUE)
# Original 25 dinemensions 0.4 resolution

#---------- Astrocyte_Markers 
# AQP4, GFAP (5,10,12,18)
vlnplot_stacked(obj = seurat_markers, 
               features = c("AQP4", "GFAP"))

FeaturePlot(seurat_markers, 
            reduction = "umap",
            features = c("AQP4", "GFAP"), 
            min.cutoff = "q10", 
            max.cutoff = "q90",
            label = TRUE)

#---------- CADPS2
# CADPS2, TIAM1 (27)
vlnplot_stacked(obj = seurat_markers, 
               features = c("CADPS2", "TIAM1"))

FeaturePlot(seurat_markers, 
            reduction = "umap",
            features = c("CADPS2", "TIAM1"), 
            min.cutoff = "q10", 
            max.cutoff = "q90",
            label = TRUE)


#---------- Dopaminergic_Markers 
# TH, SLC6A3 ()
vlnplot_stacked(obj = seurat_markers, 
               features = c("TH", "SLC6A3"))

FeaturePlot(seurat_markers, 
            reduction = "umap",
            features = c("TH", "SLC6A3"), 
            min.cutoff = "q10", 
            max.cutoff = "q90",
            label = TRUE)

#---------- Endothelial_Markers
# FLT1, DUSP1, RGS5, CLDN5 (6)
vlnplot_stacked(obj = seurat_markers, 
               features = c("FLT1", "DUSP1", "RGS5", "CLDN5"))

FeaturePlot(seurat_markers, 
            reduction = "umap",
            features = c("FLT1", "DUSP1", "RGS5", "CLDN5"), 
            min.cutoff = "q10", 
            max.cutoff = "q90",
            label = TRUE)

#---------- Ependymal_Markers
# FOXJ1 (21)
vlnplot_stacked(obj = seurat_markers, 
               features = c("FOXJ1"))

FeaturePlot(seurat_markers, 
            reduction = "umap",
            features = c("FOXJ1"), 
            min.cutoff = "q10", 
            max.cutoff = "q90",
            label = TRUE)

#---------- Excitatory_Markers
# SATB2, SLC17A6 (13,25)
vlnplot_stacked(obj = seurat_markers, 
               features = c("SATB2", "SLC17A6"))

FeaturePlot(seurat_markers, 
            reduction = "umap",
            features = c("SATB2", "SLC17A6"), 
            min.cutoff = "q10", 
            max.cutoff = "q90",
            label = TRUE)

#---------- GABA_Markers
# GRIK1 (22)
vlnplot_stacked(obj = seurat_markers, 
               features = c("GRIK1"))

FeaturePlot(seurat_markers, 
            reduction = "umap",
            features = c("GRIK1"), 
            min.cutoff = "q10", 
            max.cutoff = "q90",
            label = TRUE)

#---------- Inhibitory_Markers
# GAD1, GAD2 (9)
vlnplot_stacked(obj = seurat_markers, 
               features = c("GAD1", "GAD2"))

FeaturePlot(seurat_markers, 
            reduction = "umap",
            features = c("GAD1", "GAD2"), 
            min.cutoff = "q10", 
            max.cutoff = "q90",
            label = TRUE)

#---------- Microglia_Markers
# CSF3R, APBB1IP, CD74 (4,11,20,29,30)
vlnplot_stacked(obj = seurat_markers, 
               features = c("CSF3R", "APBB1IP", "CD74")) 

FeaturePlot(seurat_markers, 
            reduction = "umap",
            features = c("CSF3R", "APBB1IP", "CD74"), 
            min.cutoff = "q10", 
            max.cutoff = "q90",
            label = TRUE)

#---------- Oligodendrocytes_Markers
# MOG, MOBP (0,1,2,3,8,14,15,16,24,26)
vlnplot_stacked(obj = seurat_markers, 
               features = c("MOG", "MOBP")) 

FeaturePlot(seurat_markers, 
            reduction = "umap",
            features = c("MOG", "MOBP"), 
            min.cutoff = "q10", 
            max.cutoff = "q90",
            label = TRUE)

#---------- OPC_Markers
# OLIG1, VCAN (7,17)
vlnplot_stacked(obj = seurat_markers, 
               features = c("OLIG1", "VCAN"))

FeaturePlot(seurat_markers, 
            reduction = "umap",
            features = c("OLIG1", "VCAN"), 
            min.cutoff = "q10", 
            max.cutoff = "q90",
            label = TRUE)

#---------- Pericyte_Markers
# PDGFRB (19,23,28)
vlnplot_stacked(obj = seurat_markers, 
               features = c("PDGFRB"))

FeaturePlot(seurat_markers, 
            reduction = "umap",
            features = c("PDGFRB"), 
            min.cutoff = "q10", 
            max.cutoff = "q90",
            label = TRUE)

```


## Seurat Cluster_Annotation

```{r Cluster_Annotation, eval=FALSE}
#---------- Cluster_Annotation
#manually add annotations derived above
seurat_anno <- RenameIdents(seurat_markers, 
                                `0` = "Oligodendrocytes",
                                `1` = "Oligodendrocytes",
                                `2` = "Oligodendrocytes",
                                `3` = "Oligodendrocytes",
                                `4` = "Microglia",
                                `5` = "Astrocytes",
                                `6` = "Endothelial",
                                `7` = "OPC",
                                `8` = "Oligodendrocytes",
                                `9` = "Inhibitory",
                                `10` = "Astrocytes",
                                `11` = "Microglia",
                                `12` = "Astrocytes",
                                `13` = "Excitatory",
                                `14` = "Oligodendrocytes",
                                `15` = "Oligodendrocytes",
                                `16` = "Oligodendrocytes",
                                `17` = "OPC",
                                `18` = "Astrocytes",
                                `19` = "Pericytes",
                                `20` = "Microglia",
                                `21` = "Ependymal",
                                `22` = "GABA",
                                `23` = "Pericytes",
                                `24` = "Oligodendrocytes",
                                `25` = "Excitatory",
                                `26` = "Oligodendrocytes",
                                `27` = "CADPS2",
                                `28` = "Pericytes",
                                `29` = "Microglia",
                                `30` = "Microglia")

#---------- UMAP
DimPlot(seurat_anno, reduction="umap", label = TRUE)

# save these annotations in meta.data
seurat_anno@meta.data$cluster_annotation <- Idents(seurat_anno)

# Create .RData object to load at any time
save(seurat_anno, file="seurat_anno.RData")
```

```{r Clusters_plots}
# Load data
load("seurat_anno.RData")

# Remove data
rm(seurat_markers)

# UMAP cell clusters
DimPlot(seurat_anno, reduction="umap", label = TRUE, label.size = 3, repel = TRUE)

# may want to ask if we are truely seperating interneurons from excitatory
DotPlot(seurat_anno,
        features = c("AQP4", "GFAP", # Astrocyte_Markers
                     "CADPS2", "TIAM1", # CADPS2_Markers
                     "FLT1", "DUSP1", # Endothelial_Markers
                     "SATB2", "SLC17A7", # Excitatory_Markers
                     "GRIK1", # GABA_Markers
                     "GAD1", "GAD2", # Inhibitory_Markers
                     "CSF3R", "APBB1IP", # Microglia_Markers
                     "MOG", "MOBP", # Oligodendrocytes_Markers
                     "OLIG1", "VCAN", # OPC_Markers
                     "PDGFRB"), # Pericyte_Markers
        cols = c("blue", "red"), 
        dot.scale = 8) + 
  RotatedAxis()

# If we want to remove a cell cluster
#seurat_subset <- subset(seurat_integrated, idents = "Endothelial_cells", invert = TRUE)

#---------- Cluster_Cell_Counts
# Visualize the number of cell counts per cluster
seurat_anno@meta.data %>% 
  	ggplot(aes(x=cluster_annotation, fill=sample)) + 
  	geom_bar() + 
  	ggtitle("Number of Cells") + 
    theme_classic() + 
  	theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) + 
  	theme(plot.title = element_text(hjust=0.5, face="bold"))

# percentage of cell per cluster per sample
seurat_anno@meta.data %>% 
  dplyr::count(cluster_annotation, sample) %>% 
  dplyr::group_by(sample) %>% 
  dplyr::mutate(freq = n / sum(n)) %>% 
  ggplot(aes(x=cluster_annotation, y=freq, fill=sample)) + 
  geom_bar(position="dodge", stat="identity") + 
  	ggtitle("Percentage of Cells") + 
    theme_classic() + 
  	theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) + 
  	theme(plot.title = element_text(hjust=0.5, face="bold"))


#---------- Differentail Cell Proportions
# beta regression models are designed for data between 0 and 1
# This give me percent differences
# emmeans(betafit,pairwise~Group)
# emmeans(betafit,pairwise~Group,type="response")
# To test that group is important, second way to be pvaule
# betafit1 <- betareg(Oligodendrocytes ~ Group, data = cellproportions)
# betafit2 <- betareg(Oligodendrocytes ~ 1, data = cellproportions)
# lrtest(betafit1,betafit2)

cellproportions <- seurat_anno@meta.data %>% 
  dplyr::count(cluster_annotation, sample) %>% 
  dplyr::group_by(sample) %>% 
  dplyr::mutate(freq = n / sum(n)) %>%  
  dplyr::select(-n) %>% 
  tidyr::spread(cluster_annotation,freq) %>% 
  cbind(data.frame(Group = rep(c("HC", "IPD"),times=c(6, 5))))

cellproportions %>% 
  gather(key = "cluster_annotation", value = "freq", 2:12) %>% 
  ggplot(aes(x=cluster_annotation, y=freq, fill=Group)) + 
    geom_boxplot() + 
    theme_classic() + 
    scale_fill_brewer(palette="Dark2") +
    facet_wrap(~cluster_annotation, scale="free", ncol = 3)

cellproportions_betareg <- data.frame(cell_types = names(cellproportions[2:12]), 
                                      betareg_pvalue = rep(NA, times=11),
                                      betareg_diff = rep(NA, times=11))

cell_types <- names(cellproportions[2:12])
for (i in 1:11){
  cell_type <- cell_types[i]
  betafit <- betareg(as.formula(paste(cell_type, "~ Group")), data = cellproportions)
  cellproportions_betareg[i,2] <- summary(betafit)$coefficients$mean[2,4]
  cellproportions_betareg[i,3] <- exp(summary(betafit)$coefficients$mean[2,1])
}

cellproportions_betareg %>% 
  mutate_if(is.numeric, ~round(.,6)) %>% 
  DT::datatable()

```


## Seurat Conserved_Markers
  
Identification of all markers for each cluster  
This type of analysis is typically recommended for when evaluating a single  
sample group/condition. With the FindAllMarkers() function we are comparing each  
cluster against all other clusters to identify potential marker genes. The cells  
in each cluster are treated as replicates, and essentially a differential  
expression analysis is performed with some statistical test. Also, by default  
this function will return to you genes that exhibit both positive and negative  
expression changes. Typically, we add an argument only.pos to opt for keeping 
only the positive changes.  
  
Identification of conserved markers in all conditions  
Since we have samples representing different conditions in our dataset, our best  
option is to find conserved markers. This function internally separates out  
cells by sample group/condition, and then performs differential gene expression  
testing for a single specified cluster against all other clusters (or a second  
cluster, if specified). Gene-level p-values are computed for each condition and  
then combined across groups using meta-analysis methods from the MetaDE R  
package. Before we start our marker identification we will explicitly set our  
default assay, we want to use the original counts and not the integrated data.  
DefaultAssay(seurat_anno) <- "RNA"  
  
```{r Conserved_Markers, eval=FALSE}
#---------- Conserved_Markers
# Load data
load("seurat_anno.RData")

# RNA stores the original and normalized counts for finding markers
DefaultAssay(seurat_anno) <- "RNA"

# Ensembl & Symbol Gene IDs 
dir <- "counts/"
samples <- list.files(dir)
Gene_Emsembl_Symbol <- read_tsv(paste0(dir,samples[[1]],
                            "/outs/filtered_feature_bc_matrix/features.tsv.gz"),
                     col_names = c("Gene_Emsembl","Gene_Symbol","Assay_type"), 
                     col_types="ccc")[,c(1:2)] %>% 
                       unique()

cell_types <- seurat_anno$cluster_annotation %>% 
  unique() %>% as.character() %>% sort()
  
#---------- Find Conserved markers across sample groups
get_conserved <- function(seurat_rna,ident_name){
  FindConservedMarkers(seurat_rna,
                       ident.1 = ident_name, 
                       grouping.var = "group", 
                       only.pos = TRUE, 
                       min.diff.pct = 0.1, 
                       min.pct = 0.1, 
                       logfc.threshold = 0.25) %>% 
    rownames_to_column(var = "Gene_Symbol") %>% 
    left_join(Gene_Emsembl_Symbol, by="Gene_Symbol") %>% 
    dplyr::mutate(Conserved_Markers = ident_name)
  }

Conserved_Markers <- mclapply(cell_types, function(i) {
  get_conserved(seurat_anno,i) 
}) %>% bind_rows()

# save the results
write_delim(Conserved_Markers, 
            "PD_midbrain_snRNAseq_GSE157783_Conserved_Markers.txt", 
            delim = "\t")

#----- Pathways
get_gprofiler <- function(markers,ident_name){ 
   genes <- markers %>% 
      dplyr::filter(Conserved_Markers == ident_name)  
   gost(query = genes$Gene_Symbol, 
        organism = "hsapiens",
        correction_method = "g_SCS")$result %>% 
      dplyr::filter(p_value <= 0.05) %>% 
      dplyr::mutate(Conserved_Markers = ident_name) %>% 
      dplyr::select(-parents) 
  }

gprofiler_pathways <- mclapply(cell_types, function(i) {
  get_gprofiler(Conserved_Markers,i) 
}) %>% bind_rows()

# save the results
write_delim(as.data.frame(gprofiler_pathways), 
            "PD_midbrain_snRNAseq_GSE157783_Conserved_Markers_gprofiler_pathways.txt", 
            delim = "\t")

```

```{r Conserved_Markers_Counts}
# Read Marker files
Conserved_Markers <- read_delim("PD_midbrain_snRNAseq_GSE157783_Conserved_Markers.txt", 
                            "\t", escape_double = FALSE, trim_ws = TRUE)

# Number of Conserved_Markers
Conserved_Markers %>% 
  dplyr::count(Conserved_Markers) %>% 
  kable(caption="Number of Conserved_Markers", 
        format.args = list(big.mark = ",")) %>% 
  kable_styling(c("striped", "bordered"))

# Extract top 10 markers per cluster
Conserved_Markers %>% 
  group_by(Conserved_Markers) %>% 
  top_n(n = 10, 
        wt = max_pval) %>% 
  kable(caption="Top10 Conserved_Markers", 
        format.args = list(big.mark = ",")) %>% 
  kable_styling(c("striped", "bordered"))

# Searchable table
Conserved_Markers %>% 
  mutate_if(is.numeric, ~round(.,4)) %>% 
  DT::datatable()

```

```{r Conserved_Markers_Gprofiler}
# Read Pathways files
gprofiler_pathways <- read_delim("PD_midbrain_snRNAseq_GSE157783_Conserved_Markers_gprofiler_pathways.txt", 
                            "\t", escape_double = FALSE, trim_ws = TRUE)

cell_types <- seurat_anno$cluster_annotation %>% 
  unique() %>% as.character() %>% sort()

#---------- Conserved_Markers_Gprofiler
gprofiler_top10 <- function(pathway,ident_name){
  pathway %>% 
      dplyr::filter(Conserved_Markers == ident_name) %>% 
      dplyr::select(Conserved_Markers,
             source, 
             term_id, 
             term_name,
             term_size,
             query_size,
             intersection_size,
             recall,
             p_value) %>% 
    top_n(n = -10, wt = p_value) %>% 
    kable(caption="Marker Pathways Top10", 
          format.args = list(big.mark = ",")) %>% 
    kable_styling(c("striped", "bordered"))
  }

gprofiler_top10fig <- function(pathway,ident_name){
   pathway %>% 
      dplyr::filter(Conserved_Markers == ident_name) %>% 
      dplyr::select(Conserved_Markers,
             source, 
             term_id, 
             term_name,
             term_size,
             query_size,
             intersection_size,
             recall,
             p_value) %>% 
    top_n(n = -10, wt = p_value) %>% 
    ggplot(aes(x=recall, 
               y=term_name, 
               colour=p_value, 
               size=intersection_size)) + 
           geom_point() + 
           expand_limits(x=0) +
           labs(x="Hits (%)", 
                y=ident_name, 
                colour="p value", 
                size="Count") +
          theme_bw()
  }
  
gprofiler_fig <- function(markers,ident_name){
   genes <- markers %>% 
      dplyr::filter(Conserved_Markers == ident_name)  
   gost(query = genes$Gene_Symbol, 
        organism = "hsapiens",
        correction_method = "g_SCS") %>% 
      gostplot(capped = FALSE, interactive = FALSE)
  }   
   
mclapply(cell_types, function(i) {
  gprofiler_top10(gprofiler_pathways,i)
  gprofiler_top10fig(gprofiler_pathways,i)
  gprofiler_fig(Conserved_Markers,i)
})

# Searchable table
gprofiler_pathways %>% 
  dplyr::select(Conserved_Markers,
             source, 
             term_id, 
             term_name,
             term_size,
             query_size,
             intersection_size,
             recall,
             p_value) %>% 
  dplyr::mutate_if(is.numeric, ~round(.,4)) %>% 
  DT::datatable()

```


## Seurat Differential_Expression

Find DEG between old and young mice per celltype
Using 0.5 logFC

```{r Differential_Expression, eval=FALSE}
#---------- Differential_Expression
# RNA stores the original and normalized counts for finding markers
DefaultAssay(seurat_anno) <- "RNA"

# add group_cluster info to "identity" for each barcoded UMI count
seurat_anno@meta.data$group_cluster <- paste(seurat_anno@meta.data$group, seurat_anno@meta.data$cluster_annotation, sep = "_")

# make this the Idents()
Idents(seurat_anno) <- seurat_anno$group_cluster

#---------- Find Differential expressed genes between groups
get_deg <- function(seurat_rna,ident1,ident2){
  FindMarkers(seurat_rna, 
              ident.1 = ident1, 
              ident.2 = ident2, 
              test.use = "MAST", 
              latent.vars = NULL, 
              logfc.threshold = 0, 
              min.pct = 0,
              min.diff.pct = -Inf, 
              min.cells.feature = 10, 
              min.cells.group = 10, 
              verbose = FALSE) %>% 
    rownames_to_column(var = "Gene_Symbol") %>% 
    left_join(Gene_Emsembl_Symbol, by="Gene_Symbol") %>% 
    dplyr::mutate(Comparison = paste(ident1, ident2, sep = "_vs_"))
}

#---------- DEG 
cell_types <- seurat_anno$cluster_annotation %>% 
  unique() %>% as.character() %>% sort()

DEG <- mclapply(cell_types, mc.cores = 5, function(i) {
  id1 <- paste0("IPD_",i)
  id2 <- paste0("HC_",i)
  get_deg(seurat_anno,id1,id2) 
}) %>% bind_rows()

# save the results
write_delim(DEG, 
  "PD_midbrain_snRNAseq_GSE157783_IPDvsHC_DEG_MAST.txt", 
  delim = "\t")
```

```{r Differential_Expression_Counts}
# Read Marker files
DEG <- read_delim("PD_midbrain_snRNAseq_GSE157783_IPDvsHC_DEG_MAST.txt", 
                            "\t", escape_double = FALSE, trim_ws = TRUE)

# Number of DEGs
merge(DEG %>% 
        dplyr::count(Comparison) %>%
        dplyr::rename(Total_Genes = n), 
      DEG %>% 
        dplyr::filter(p_val_adj <= 0.05 & avg_logFC >= 0.25 | 
               p_val_adj <= 0.05 & avg_logFC <= -0.25) %>% 
        dplyr::count(Comparison) %>%
        dplyr::rename(Genes_FDR0.05_logFC0.25 = n), 
      by = "Comparison") %>% 
  kable(caption="Number of Differentially Expressed Genes", 
        format.args = list(big.mark = ",")) %>% 
  kable_styling(c("striped", "bordered"))

# Extract top 10 DEGs per cluster
DEG %>% 
  group_by(Comparison) %>% 
  top_n(n = -10, 
        wt = p_val_adj) %>% 
  kable(caption="Differentially Expressed Genes", 
        format.args = list(big.mark = ",")) %>% 
  kable_styling(c("striped", "bordered"))

# Searchable table
DEG %>% 
  filter(p_val_adj <= 0.05 & avg_logFC >= 0.25 | 
               p_val_adj <= 0.05 & avg_logFC <= -0.25) %>% 
  select(Comparison,
         Gene_Symbol, 
         Gene_Emsembl, 
         pct.1,
         pct.2,
         p_val,
         p_val_adj,
         avg_logFC) %>% 
  mutate_if(is.numeric, ~round(.,4)) %>% 
  DT::datatable()

```


## Seurat Differential_Expression_Senescence_Pathways

Senescence Pathways  

```{r Differential_Expression_Senescence, eval=FALSE}
# Read Marker files
DEG_sig <- DEG %>% filter(p_val_adj <= 0.05 & avg_logFC >= 0.25 | 
                                p_val_adj <= 0.05 & avg_logFC <= -0.25)

# Senescence_Pathways
comparison_names = unique(DEG$Comparison)
pathways_names = list.files("../Senescence/human/")

senescence_enrichment <- mclapply(comparison_names, function(i) { 
  mclapply(pathways_names, function(p) { 
    pathway <- read_delim(paste0("../Senescence/human/",p), 
                          "\t", escape_double = FALSE, trim_ws = TRUE)
    genes <- DEG %>% filter(Comparison == i) %>% nrow()
    sig_genes <- DEG_sig %>% filter(Comparison == i) %>% nrow()
    pathway_back_genes <- DEG %>% filter(Comparison == i) %>% 
                          filter(Gene_Symbol %in% pathway$Gene_Symbol) %>% nrow()
    pathway_sig_genes <- DEG_sig %>% filter(Comparison == i) %>% 
                         filter(Gene_Symbol %in% pathway$Gene_Symbol) %>% nrow()
    enrichment <- data.frame(rbind(Background=c(genes-sig_genes, sig_genes), 
                  Foreground= c(pathway_back_genes-pathway_sig_genes, pathway_sig_genes)))
    names(enrichment) <- c("Nonsignificant","Significant") 
    data.frame("Comparison" = i,
               "Genes" = genes,
               "Sig_Genes" = sig_genes,
               "Pathway" = p, 
               "Pathway_Genes" = nrow(pathway), 
               "Pathway_Back_Genes" = pathway_back_genes,
               "Pathway_Sig_Genes" = pathway_sig_genes,
               "Fisher_Pvalue" = fisher.test(enrichment, alternative="greater")$p.value,
               "Fisher_OddsRatio" = fisher.test(enrichment, alternative="greater")$estimate)
  })
}) %>% bind_rows()

# save the results
write_delim(senescence_enrichment, 
  "PD_midbrain_snRNAseq_GSE157783_IPDvsHC_DEG_MAST_Senescence_Pathways.txt", 
  delim = "\t")
```

```{r Differential_Expression_Senescence_Counts}
# Read Senescence_Pathways
senescence_enrichment <- 
  read_delim("PD_midbrain_snRNAseq_GSE157783_IPDvsHC_DEG_MAST_Senescence_Pathways.txt", 
                            "\t", escape_double = FALSE, trim_ws = TRUE)

# Searchable table
senescence_enrichment %>% 
  arrange(Fisher_Pvalue) %>% 
  mutate(Fisher_Pvalue = round(Fisher_Pvalue, 4), 
         Fisher_OddsRatio = round(Fisher_OddsRatio, 2)) %>% 
  DT::datatable()

```


## Seurat Differential_Expression_Lysosome_Pathways

Lysosome Pathways  

```{r Differential_Expression_Lysosome, eval=FALSE}
# Read Marker files
DEG_sig <- DEG %>% filter(p_val_adj <= 0.05 & avg_logFC >= 0.25 | 
                                p_val_adj <= 0.05 & avg_logFC <= -0.25)

# Lysosome_Pathways
comparison_names <- unique(DEG$Comparison)
pathways_names <- list.files("lysosomal_pathways/")

lysosome_enrichment <- mclapply(comparison_names, function(i) { 
  mclapply(pathways_names, function(p) { 
    pathway <- read_delim(paste0("lysosomal_pathways/",p), 
                          "\t", escape_double = FALSE, trim_ws = TRUE)
    genes <- DEG %>% filter(Comparison == i) %>% nrow()
    sig_genes <- DEG_sig %>% filter(Comparison == i) %>% nrow()
    pathway_back_genes <- DEG %>% filter(Comparison == i) %>% 
                          filter(Gene_Symbol %in% pathway$Gene_Symbol) %>% nrow()
    pathway_sig_genes <- DEG_sig %>% filter(Comparison == i) %>% 
                         filter(Gene_Symbol %in% pathway$Gene_Symbol) %>% nrow()
    enrichment <- data.frame(rbind(Background=c(genes-sig_genes, sig_genes), 
                  Foreground= c(pathway_back_genes-pathway_sig_genes, pathway_sig_genes)))
    names(enrichment) <- c("Nonsignificant","Significant") 
    data.frame("Comparison" = i,
               "Genes" = genes,
               "Sig_Genes" = sig_genes,
               "Pathway" = p, 
               "Pathway_Genes" = nrow(pathway), 
               "Pathway_Back_Genes" = pathway_back_genes,
               "Pathway_Sig_Genes" = pathway_sig_genes,
               "Fisher_Pvalue" = fisher.test(enrichment, alternative="greater")$p.value,
               "Fisher_OddsRatio" = fisher.test(enrichment, alternative="greater")$estimate)
  })
}) %>% bind_rows()

# save the results
write_delim(lysosome_enrichment, 
  "PD_midbrain_snRNAseq_GSE157783_IPDvsHC_DEG_MAST_Lysosome_Pathways.txt", 
  delim = "\t")
```

```{r Differential_Expression_Lysosome_Counts}
# Read Senescence_Pathways
lysosome_enrichment <- 
  read_delim("PD_midbrain_snRNAseq_GSE157783_IPDvsHC_DEG_MAST_Lysosome_Pathways.txt", 
                            "\t", escape_double = FALSE, trim_ws = TRUE)

# Searchable table
lysosome_enrichment %>% 
  arrange(Fisher_Pvalue) %>% 
  mutate(Fisher_Pvalue = round(Fisher_Pvalue, 4), 
         Fisher_OddsRatio = round(Fisher_OddsRatio, 2)) %>% 
  DT::datatable()

```


## Seurat Differential_Expression_GSEA

```{r Differential_Expression_GSEA, eval=FALSE}
#---------- Differential_Expression_GSEA
# EDIT GMT FILE cut -f 2 -d$'\t' --complement
gmt_file <- gmtPathways("Human_GOBP_AllPathways_no_GO_iea_January_13_2021_symbol_fgsea.gmt")

comparison_names <- unique(DEG$Comparison)

fgsea_enrichment <- mclapply(comparison_names, function(i) {
  rnk_file <- DEG %>% 
    dplyr::filter(Comparison == i) %>% 
    dplyr::select(Comparison, 
           Gene_Symbol, 
           p_val, 
           avg_logFC) %>% 
    dplyr::mutate(sign_log10Pvalue = sign(avg_logFC) * -log10(p_val)) %>% 
    dplyr::arrange(sign_log10Pvalue)
  rnk_file <- setNames(rnk_file$sign_log10Pvalue, rnk_file$Gene_Symbol)
  fgsea_rnk <- fgsea(gmt_file, rnk_file, nperm=1000, minSize=10, maxSize=500)
  fgsea_rnk %>% 
    dplyr::mutate(Comparison = i) %>% 
    dplyr::select(-leadingEdge)
}) %>% bind_rows()

# save the results
write_delim(fgsea_enrichment, 
  "PD_midbrain_snRNAseq_GSE157783_IPDvsHC_DEG_MAST_fgsea_enrichment.txt", 
  delim = "\t")
```

```{r Differential_Expression_GSEA_Counts}
# Read fgsea_enrichment
fgsea_enrichment <- 
  read_delim("PD_midbrain_snRNAseq_GSE157783_IPDvsHC_DEG_MAST_fgsea_enrichment.txt", 
                            "\t", escape_double = FALSE, trim_ws = TRUE)

# Number of Pathways
fgsea_enrichment %>% 
  dplyr::filter(padj <= 0.05) %>% 
  dplyr::count(Comparison) %>%
  dplyr::rename(Pathways_FDR0.05 = n) %>% 
  kable(caption="Number of Pathways", 
        format.args = list(big.mark = ",")) %>% 
  kable_styling(c("striped", "bordered"))

# Searchable table
fgsea_enrichment %>% 
  dplyr::filter(padj <= 0.05) %>% 
  dplyr::arrange(padj) %>% 
  dplyr::select(Comparison, 
         pathway, 
         pval, 
         padj, 
         ES, 
         NES) %>% 
  mutate_if(is.numeric, ~round(.,4)) %>% 
  DT::datatable()
```


## Seurat Senescence_Markers

Cdkn2a used as a marker for senescence

```{r Senescence_Markers}
# Cell clusters
Idents(seurat_anno) <- seurat_anno@meta.data$cluster_annotation

# UMAP cell clusters
DimPlot(seurat_anno, 
        reduction="umap", 
        label = TRUE, 
        label.size = 3, 
        repel = TRUE, 
        split.by = "group")

# Cellular Senescence Markers p16-Ink4a
FeaturePlot(seurat_anno, 
            reduction = "umap", 
            features = c("CDKN2A"), 
            split.by = "group", 
            label = FALSE)

Idents(seurat_anno, WhichCells(object = seurat_anno, 
                               expression = CDKN2A > 1, 
                               slot = 'data')) <- 'CDKN2A_pos'
Idents(seurat_anno, WhichCells(object = seurat_anno, 
                               expression = CDKN2A <= 1, 
                               slot = 'data')) <- 'CDKN2A_neg'

seurat_anno@meta.data$CDKN2A <- Idents(seurat_anno) 
cell_types <- unique(seurat_anno$cluster_annotation)

CDKN2A <- lapply(cell_types, function(i) { 
  IPD_neg <- seurat_anno@meta.data %>% 
             filter(cluster_annotation == i & group == "IPD" & 
             CDKN2A == "CDKN2A_neg") %>% nrow()
  IPD_pos <- seurat_anno@meta.data %>% 
             filter(cluster_annotation == i & group == "IPD" & 
             CDKN2A == "CDKN2A_pos") %>% nrow()
  HC_neg <- seurat_anno@meta.data %>% 
               filter(cluster_annotation == i & group == "HC" & 
               CDKN2A == "CDKN2A_neg") %>% nrow() 
  HC_pos <- seurat_anno@meta.data %>% 
               filter(cluster_annotation == i & group == "HC" & 
               CDKN2A == "CDKN2A_pos") %>% nrow()
  data.frame("Comparison" = i,
             "IPD_CDKN2A_neg" = IPD_neg,
             "IPD_CDKN2A_pos" = IPD_pos,
             "HC_CDKN2A_neg" = HC_neg, 
             "HC_CDKN2A_pos" = HC_pos, 
             "IPD_CDKN2A_Percentage" = IPD_pos/(IPD_neg+IPD_pos)*100,
             "HC_CDKN2A_Percentage" = HC_pos/(HC_neg+HC_pos)*100)
}) %>% bind_rows()

CDKN2A %>% 
  mutate(IPD_CDKN2A_Percentage = round(IPD_CDKN2A_Percentage, 4), 
         HC_CDKN2A_Percentage = round(HC_CDKN2A_Percentage, 4)) %>% 
  DT::datatable()

# Boxplot of CDKN2A
df <- cbind(seurat_anno@meta.data %>% 
  dplyr::select(cluster_annotation, CDKN2A, group, sample),
  data = seurat_anno@assays$RNA@data["CDKN2A",])

ggboxplot(df, x = "group", y = "data",
                color = "group", palette =c("#00AFBB", "#E7B800"),
                add = "jitter", shape = "group", size = 0.2, 
          title = "CDKN2A normalized counts", facet.by = "cluster_annotation")

#---------- Senescence Markers p21 Wafl/Clp1/Sdi1
FeaturePlot(seurat_anno, 
            reduction = "umap", 
            features = c("CDKN1A"), 
            split.by = "group", 
            label = FALSE)

Idents(seurat_anno, WhichCells(object = seurat_anno, 
                               expression = CDKN1A > 1, 
                               slot = 'data')) <- 'CDKN1A_pos'
Idents(seurat_anno, WhichCells(object = seurat_anno, 
                               expression = CDKN1A <= 1, 
                               slot = 'data')) <- 'CDKN1A_neg'

seurat_anno@meta.data$CDKN1A <- Idents(seurat_anno) 
cell_types <- unique(seurat_anno$cluster_annotation)

CDKN1A <- lapply(cell_types, function(i) { 
  IPD_neg <- seurat_anno@meta.data %>% 
             filter(cluster_annotation == i & group == "IPD" & 
             CDKN1A == "CDKN1A_neg") %>% nrow()
  IPD_pos <- seurat_anno@meta.data %>% 
             filter(cluster_annotation == i & group == "IPD" & 
             CDKN1A == "CDKN1A_pos") %>% nrow()
  HC_neg <- seurat_anno@meta.data %>% 
               filter(cluster_annotation == i & group == "HC" & 
               CDKN1A == "CDKN1A_neg") %>% nrow() 
  HC_pos <- seurat_anno@meta.data %>% 
               filter(cluster_annotation == i & group == "HC" & 
               CDKN1A == "CDKN1A_pos") %>% nrow()
  data.frame("Comparison" = i,
             "IPD_CDKN1A_neg" = IPD_neg,
             "IPD_CDKN1A_pos" = IPD_pos,
             "HC_CDKN1A_neg" = HC_neg, 
             "HC_CDKN1A_pos" = HC_pos, 
             "IPD_CDKN1A_Percentage" = IPD_pos/(IPD_neg+IPD_pos)*100,
             "HC_CDKN1A_Percentage" = HC_pos/(HC_neg+HC_pos)*100)
}) %>% bind_rows()

CDKN1A %>% 
  mutate(IPD_CDKN1A_Percentage = round(IPD_CDKN1A_Percentage, 4), 
         HC_CDKN1A_Percentage = round(HC_CDKN1A_Percentage, 4)) %>% 
  DT::datatable()

# Boxplot of CDKN1A
df <- cbind(seurat_anno@meta.data %>% 
  dplyr::select(cluster_annotation, CDKN1A, group, sample),
  data = seurat_anno@assays$RNA@data["CDKN1A",])

ggboxplot(df, x = "group", y = "data",
                color = "group", palette =c("#00AFBB", "#E7B800"),
                add = "jitter", shape = "group", size = 0.2, 
          title = "CDKN1A normalized counts", facet.by = "cluster_annotation")


#---------- Senescence Markers p53 TP53
FeaturePlot(seurat_anno, 
            reduction = "umap", 
            features = c("TP53"), 
            split.by = "group", 
            label = FALSE)

Idents(seurat_anno, WhichCells(object = seurat_anno, 
                               expression = TP53 > 1, 
                               slot = 'data')) <- 'TP53_pos'
Idents(seurat_anno, WhichCells(object = seurat_anno, 
                               expression = TP53 <= 1, 
                               slot = 'data')) <- 'TP53_neg'

seurat_anno@meta.data$TP53 <- Idents(seurat_anno) 
cell_types <- unique(seurat_anno$cluster_annotation)

TP53 <- lapply(cell_types, function(i) { 
  IPD_neg <- seurat_anno@meta.data %>% 
             filter(cluster_annotation == i & group == "IPD" & 
             TP53 == "TP53_neg") %>% nrow()
  IPD_pos <- seurat_anno@meta.data %>% 
             filter(cluster_annotation == i & group == "IPD" & 
             TP53 == "TP53_pos") %>% nrow()
  HC_neg <- seurat_anno@meta.data %>% 
               filter(cluster_annotation == i & group == "HC" & 
               TP53 == "TP53_neg") %>% nrow() 
  HC_pos <- seurat_anno@meta.data %>% 
               filter(cluster_annotation == i & group == "HC" & 
               TP53 == "TP53_pos") %>% nrow()
  data.frame("Comparison" = i,
             "IPD_TP53_neg" = IPD_neg,
             "IPD_TP53_pos" = IPD_pos,
             "HC_TP53_neg" = HC_neg, 
             "HC_TP53_pos" = HC_pos, 
             "IPD_TP53_Percentage" = IPD_pos/(IPD_neg+IPD_pos)*100,
             "HC_TP53_Percentage" = HC_pos/(HC_neg+HC_pos)*100)
}) %>% bind_rows()

TP53 %>% 
  mutate(IPD_TP53_Percentage = round(IPD_TP53_Percentage, 4), 
         HC_TP53_Percentage = round(HC_TP53_Percentage, 4)) %>% 
  DT::datatable()

# Boxplot of TP53
df <- cbind(seurat_anno@meta.data %>% 
  dplyr::select(cluster_annotation, TP53, group, sample),
  data = seurat_anno@assays$RNA@data["TP53",])

ggboxplot(df, x = "group", y = "data",
                color = "group", palette =c("#00AFBB", "#E7B800"),
                add = "jitter", shape = "group", size = 0.2, 
          title = "TP53 normalized counts", facet.by = "cluster_annotation")


#---------- Senescence Markers Beta-galactosidase GLB1
FeaturePlot(seurat_anno, 
            reduction = "umap", 
            features = c("GLB1"), 
            split.by = "group", 
            label = FALSE)

Idents(seurat_anno, WhichCells(object = seurat_anno, 
                               expression = GLB1 > 1, 
                               slot = 'data')) <- 'GLB1_pos'
Idents(seurat_anno, WhichCells(object = seurat_anno, 
                               expression = GLB1 <= 1, 
                               slot = 'data')) <- 'GLB1_neg'

seurat_anno@meta.data$GLB1 <- Idents(seurat_anno) 
cell_types <- unique(seurat_anno$cluster_annotation)

GLB1 <- lapply(cell_types, function(i) { 
  IPD_neg <- seurat_anno@meta.data %>% 
             filter(cluster_annotation == i & group == "IPD" & 
             GLB1 == "GLB1_neg") %>% nrow()
  IPD_pos <- seurat_anno@meta.data %>% 
             filter(cluster_annotation == i & group == "IPD" & 
             GLB1 == "GLB1_pos") %>% nrow()
  HC_neg <- seurat_anno@meta.data %>% 
               filter(cluster_annotation == i & group == "HC" & 
               GLB1 == "GLB1_neg") %>% nrow() 
  HC_pos <- seurat_anno@meta.data %>% 
               filter(cluster_annotation == i & group == "HC" & 
               GLB1 == "GLB1_pos") %>% nrow()
  data.frame("Comparison" = i,
             "IPD_GLB1_neg" = IPD_neg,
             "IPD_GLB1_pos" = IPD_pos,
             "HC_GLB1_neg" = HC_neg, 
             "HC_GLB1_pos" = HC_pos, 
             "IPD_GLB1_Percentage" = IPD_pos/(IPD_neg+IPD_pos)*100,
             "HC_GLB1_Percentage" = HC_pos/(HC_neg+HC_pos)*100)
}) %>% bind_rows()

GLB1 %>% 
  mutate(IPD_GLB1_Percentage = round(IPD_GLB1_Percentage, 4), 
         HC_GLB1_Percentage = round(HC_GLB1_Percentage, 4)) %>% 
  DT::datatable()

# Boxplot of GLB1
df <- cbind(seurat_anno@meta.data %>% 
  dplyr::select(cluster_annotation, GLB1, group, sample),
  data = seurat_anno@assays$RNA@data["GLB1",])

ggboxplot(df, x = "group", y = "data",
                color = "group", palette =c("#00AFBB", "#E7B800"),
                add = "jitter", shape = "group", size = 0.2, 
          title = "GLB1 normalized counts", facet.by = "cluster_annotation")

```














